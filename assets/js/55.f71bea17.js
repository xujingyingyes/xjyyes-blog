(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{236:function(t,s,e){"use strict";e.r(s);var n=e(0),a=Object(n.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"content"},[t._m(0),t._v(" "),e("p",[t._v("常见的 7 种时间复杂度")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),e("p",[t._v("我们不需要考虑常数系数，即")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),e("p",[t._v("所以，我们在写程序的时候，需要严格的考虑时间空间复杂度。")]),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),e("p",[t._v("方法：利用递归的执行顺序，画出递归的树形结构，称之为递归状态树。")]),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),e("p",[t._v("分析最简单的解决方案：")]),t._v(" "),t._m(13),t._m(14),t._v(" "),e("p",[t._v("我们可以看到两个现象：")]),t._v(" "),t._m(15),t._v(" "),e("h2",{attrs:{id:"主定理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主定理"}},[t._v("#")]),t._v(" "),e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86",target:"_blank",rel:"noopener noreferrer"}},[t._v("主定理"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("任何递归、分治的方法都可以使用主定理来计算时间复杂度")]),t._v(" "),e("p",[t._v("主要有下面四种情况：")]),t._v(" "),t._m(16),t._v(" "),e("p",[t._v("翻译成中文：")]),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),e("p",[t._v("关键点：")]),t._v(" "),t._m(21)])}),[function(){var t=this.$createElement,s=this._self._c||t;return s("h1",{attrs:{id:"时间复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[this._v("#")]),this._v(" 时间复杂度")])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ul",[e("li",[e("code",[t._v("O(1)")]),t._v(" 常数复杂度")]),t._v(" "),e("li",[e("code",[t._v("O(log n)")]),t._v(" 对数复杂度")]),t._v(" "),e("li",[e("code",[t._v("O(n)")]),t._v(" 线性时间复杂度")]),t._v(" "),e("li",[e("code",[t._v("O(n^2)")]),t._v(" 平方")]),t._v(" "),e("li",[e("code",[t._v("O(n^3)")]),t._v(" 立方")]),t._v(" "),e("li",[e("code",[t._v("O(2^n)")]),t._v(" 指数")]),t._v(" "),e("li",[e("code",[t._v("O(n!)")]),t._v(" 阶乘")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("blockquote",[s("p",[this._v("最简单判断时间复杂度的方法：查看当前函数执行的次数")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("code",[this._v("O(2n) === O(n)")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/LaamGinghong/pics/master/img/20200904213919.png",alt:"时间复杂度曲线"}})])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"计算-1-2-3-4-n"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算-1-2-3-4-n"}},[this._v("#")]),this._v(" 计算 1 + 2 + 3 + 4 + ... + n")])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ol",[e("li",[e("p",[t._v("从 1 到 n 的循环累加")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" res "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  res "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" i\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("因为进行了 n 次循环，所以时间复杂度是 "),e("code",[t._v("O(n)")]),t._v("。")])]),t._v(" "),e("li",[e("p",[t._v("求和公式 "),e("code",[t._v("sum = n * (n + 1) / 2")])]),t._v(" "),e("p",[t._v("程序只执行了一次，所以时间复杂度是 "),e("code",[t._v("O(1)")]),t._v("。")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"面试四要素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试四要素"}},[this._v("#")]),this._v(" 面试四要素")])},function(){var t=this.$createElement,s=this._self._c||t;return s("ol",[s("li",[this._v("首先和面试官确认题目的意思")]),this._v(" "),s("li",[this._v("想尽所有可能解决的方案")]),this._v(" "),s("li",[this._v("比较各个方法之间的时间和空间复杂度，找出最优的解决方案")]),this._v(" "),s("li",[this._v("测试结果")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"递归"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[this._v("#")]),this._v(" 递归")])},function(){var t=this.$createElement,s=this._self._c||t;return s("blockquote",[s("p",[this._v("核心：理解递归直线了多少次。")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",{attrs:{id:"求斐波那契数列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#求斐波那契数列"}},[this._v("#")]),this._v(" 求斐波那契数列")])},function(){var t=this.$createElement,s=this._self._c||t;return s("blockquote",[s("p",[this._v("递推公式："),s("code",[this._v("F(n) = F(n - 1) + F(n - 2)")])])])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"language-typescript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-typescript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("fib")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("fib")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("fib")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/LaamGinghong/pics/master/img/20200904215438.png",alt:""}})])},function(){var t=this.$createElement,s=this._self._c||t;return s("ol",[s("li",[this._v("每多展开一层，节点数比上一层多一倍，所以大概判断在第 n 层的节点数为 2 ^ n 次方个，呈指数型增长；")]),this._v(" "),s("li",[this._v("各层之间的节点存在重复出现的节点 ，所以有非常多的冗余数据")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/LaamGinghong/pics/master/img/20200904215657.png",alt:""}})])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("table",[e("thead",[e("tr",[e("th",[t._v("算法")]),t._v(" "),e("th",[t._v("时间复杂度")]),t._v(" "),e("th",[t._v("递推公式")]),t._v(" "),e("th",[t._v("解释")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("二分查找")]),t._v(" "),e("td",[e("code",[t._v("O(logn)")])]),t._v(" "),e("td",[e("code",[t._v("T(n) = T(n / 2) + O(1)")])]),t._v(" "),e("td",[t._v("每次都一分为二，越分越小")])]),t._v(" "),e("tr",[e("td",[t._v("二叉树遍历")]),t._v(" "),e("td",[e("code",[t._v("O(n)")])]),t._v(" "),e("td",[e("code",[t._v("T(n) = 2 * T(n / 2) + O(1)")])]),t._v(" "),e("td",[t._v("每次都一分为二，但是每一边都是相等的时间复杂度")])]),t._v(" "),e("tr",[e("td",[t._v("排序二维矩阵二分查找")]),t._v(" "),e("td",[e("code",[t._v("O(n)")])]),t._v(" "),e("td",[e("code",[t._v("T(n) = 2 * T(n / 2) + O(logn)")])]),t._v(" "),e("td",[t._v("一维二分查找的平方")])]),t._v(" "),e("tr",[e("td",[t._v("归并排序")]),t._v(" "),e("td",[e("code",[t._v("O(nlogn)")])]),t._v(" "),e("td",[e("code",[t._v("T(n) = 2 * T(n / 2) + O(n)")])]),t._v(" "),e("td")])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h2",{attrs:{id:"面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[this._v("#")]),this._v(" 面试题")])},function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ul",[e("li",[e("p",[t._v("二叉树的前序、中序、后序遍历的时间复杂度")]),t._v(" "),e("p",[e("code",[t._v("O(n)")]),t._v("：二叉树的每个节点有且仅访问一次")])]),t._v(" "),e("li",[e("p",[t._v("图的遍历时间复杂度")]),t._v(" "),e("p",[e("code",[t._v("O(n)")]),t._v("：图中的每个节点有且仅访问一次")])]),t._v(" "),e("li",[e("p",[t._v("搜索算法：DFS（深度优先）、BFS（广度优先） 时间复杂度是多少？")]),t._v(" "),e("p",[t._v("都是 "),e("code",[t._v("O(n)")]),t._v("，因为每个节点都只复杂一次。")])]),t._v(" "),e("li",[e("p",[t._v("二分查找的时间复杂度")]),t._v(" "),e("p",[e("code",[t._v("O(logn)")])])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h1",{attrs:{id:"空间复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度"}},[this._v("#")]),this._v(" 空间复杂度")])},function(){var t=this.$createElement,s=this._self._c||t;return s("ol",[s("li",[this._v("数组的长度")]),this._v(" "),s("li",[this._v("递归的深度")])])}],!1,null,null,null);s.default=a.exports}}]);